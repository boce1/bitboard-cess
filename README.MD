# Bitboard Chess Engine

## Features

- **Bitboard Representation** – Fast move generation and board manipulation using 64-bit integers.  
- **Move Generation** – Legal and pseudo-legal moves for all pieces.  
- **Negamax Search** – Implements the negamax variant of minimax with alpha-beta pruning.  
- **Quiescence Search** – Extends leaf nodes to reduce the horizon effect.  
- **Move Ordering** – Includes killer moves, history heuristics, and principal variation (PV) search.  
- **Evaluation Function** – Basic material + positional evaluation (can be extended).  
- **UCI Protocol** – Communicates with GUIs like **Arena**, **CuteChess**, or **lichess-bot**.  
- **Perft Testing** – Verify correctness of move generation.  
- **Principle variation search** - Improves the performance up to 10%

## Build Instructions
### Requirements
- GCC compiller
- make tool for reading and executing the makefile

### Compile
Clone the repo
```bash
git clone https://github.com/boce1/bitboard-chess.git
cd bitboard-chess
```

To run the "release" version of the chess bot
```bash
make
./bin/bitboard_chess_release
```

For debug
```bash
make debug
./bin/bitboard_chess_debug
```

## References
1. This project is inspired by and follows the tutorial series from Maksim Korzh.
- Youtube series: https://youtube.com/playlist?list=PLmN0neTso3Jxh8ZIylk74JpwfiWNI76Cs&si=Sd3jy2bCRtksQ3oJ
- Github repo of his engine: https://github.com/maksimKorzh/bbc.git
2. Principle Variation Search by Bruce Moreland : https://web.archive.org/web/20071030220825/http://www.brucemo.com/compchess/programming/pvs.htm#expand
3. Manimax and alpha-beta lecture - MIT OpenCourseWare : https://youtu.be/STjW3eH0Cik?si=kpKddQLv2FGQYds4
4. Minimax and alpha-beta pruning algortyhm - Sebastian Lague : https://www.youtube.com/watch?v=l-hh51ncgDI
5. Magic numbers and magic bitboard for move generation
- TimosPal, repo: https://github.com/TimosPal/NNUE-Bitboard-Chess-Engine
- Chess programming wiki : https://www.chessprogramming.org/Magic_Bitboards

## Running the engine
This engine works with UCI protocol and every GUI that supports UCI can start the bot. The most popular GUI for chess engines are:
- Arena
- Lucas Chess
- Tarrasch
- Cute Chess

### For windows
To play this engine just load ```bitboard_chess_release.exe```.
### For Unix based OS
Executable ```bitboard_chess_release.exe``` in the ```bin``` folder is only Windows compatable. For Unix systems the program needs to be compiled and then loaded in a GUI. Instructions are in [Build Instructions](#build-instructions) section.

# Bitboards
Bitboards (also called bitmaps) are unsigned 64-bit integers. They are used to represent the state of the board. This method offers great computational speed because bitboard can be manipulated with binary operation. Modern computers are 64-bit arhitectures wich allows ussability of 64 bit registers. Binary operations with 64bit registers are much faster than the standard 2d representation of the board.

# Board
Board is a structure that contains occupancy of all 12 pieces (pawn, rook, knight, bishop, queen. king for black and white), occupancies for white and black pieces and occupancy of all pieces of the board. The occupancies are represented as bitboards. Board also contains variables for wich side is to move, en passant sqaure and castling rights.

# Move generation
For move generation there's two move categories: pseudo moves and legal moves. A pseudo move is a move that is legal if we leave the fact that the move might make the king in check or let the king be checked. Legal move is a move that doesn't allow the king to be in check position. Algorithm first generates the pseudo moves then it filtrates them afterwards. All the attacks are pre-generated at startup. This way getting the pseudo moves is faster because theres no need to calculate them on the fly. Exception in this implementation are pawn pushes and king castles. They are being calculated on the fly.

In context of generating moves there's two types of pieces: 
- leaper pieces (pawns, king, knight)
- slider pieces (rook, bishop, queen)

For slider pieces getting the attack mask is done by multiply-right-shift perfect hashing algorithm. Depending on the relevant occupancy bits, function gives the index of the attack bitboard. 
Terminology:
- Relevant occupancy bits are bitmask that represents the squares that have pieces that are in the tragectory of slider piece attack. The edge squares aren't included because they are not in the way of the rays (Rays end at the edge squares). 
- Magic number is the unique unsigned 64 bit integer when being multiplied with relevant occupancy bitmask gives consecutive combination of the masked bits. That combination is then right-shifted creating the index of the attack mask. Magic numbers can be generated by brute-force trial and error.
How does it work:
1. Mask the relevant occupancy bits to form a key
2. Multiply the key by a "magic number" to obtain an index mapping
3. Right shift the index mapping by 64-n bits to create an index, where n is the number of bits in the index. A better magic number will have less bits required in the index
4. Use the index to reference a preinitialized move database
The picture bellow show the visualization of the stuff explain above. It's refrenced from [TimosPal's chess engine](#references).
![magic numbers example](pics/magic_bitboards_example.png)

# Moves
For sipmlicity and performance purposes moves are represented as unsigned 32bit integer. The move contains information about source square, target square, piece, promotion piece (if piece is pawn and its promoted), cpature flag, double push flag (if piece is pawn), enpassant flag (if piece is pawn), castiling flag (if piece is king).
- target and source square are encoded as 6 bits each, representing the 64 (2^6) squares on the board
- piece and promotion piece are encoded as 4 bits each, representing the 12 pieces
- capture flag, double push flag, enpassant flag, castling flag are encoded as 1 bit each
- total size of the move is 6 + 6 + 4 + 4 + 1 + 1 + 1 + 1 = 24 bits (3 bytes)

| Binary Representation         | Description             | Hex Value  |
|-------------------------------|-------------------------|------------|
| `0000 0000 0000 0000 0011 1111` | Source square mask      | `0x3f`     |
| `0000 0000 0000 1111 1100 0000` | Target square mask      | `0xfc0`    |
| `0000 0000 1111 0000 0000 0000` | Piece mask              | `0xf000`   |
| `0000 1111 0000 0000 0000 0000` | Promotion piece mask    | `0xf0000`  |
| `0001 0000 0000 0000 0000 0000` | Capture flag mask       | `0x100000` |
| `0010 0000 0000 0000 0000 0000` | Double push flag mask   | `0x200000` |
| `0100 0000 0000 0000 0000 0000` | En passant flag mask    | `0x400000` |
| `1000 0000 0000 0000 0000 0000` | Castling flag mask      | `0x800000` |

Castiling right is also represented as 32bit integer where the first bit is the right for white to castle on king side, second bit is right for white to castle on queen side, third bit is the right for black to castle on king side, forth bit is the right for black to castle on the queen side. wk = 1, wq = 2, bk = 4, bq = 8
The rights for castle are updated with move. When move is made it bitwise castling right with constants for removing the bits. new_castling_rights = castling_rights & move_update
| Move                        | Binary | Decimal |
|-----------------------------|--------|---------|
| White king moved            | `1100` | 12      |
| White king's rook moved     | `1110` | 14      |
| White queen's rook moved    | `1101` | 13      |
| Black king moved            | `0011` | 3       |
| Black king's rook moved     | `1011` | 11      |
| Black queen's rook moved    | `0111` | 7       |

Moves are stored in move list structure that constains count of moves at the given positon and array of ints with size of 256 (maxumum numbers of moves at the most complex position).

# Negamax
For more detailed explanation check the [MIT lecture for Minimax and Lague's youtube video](#references).

Negamax is version of minimax where instead of having two separate function for minimazing and maximazing there's only one function that flips the sign of the score. max(score) = -min(-score). Intuition is what is good for the opponent is bad for me and vice versa.
Alpa-beta prunning is technic that cuts off branches where it's sure the opponent won't go that path. The branches that we know are uselles to visit, recursive negamax call isnt done on them. Alpha is variable that holds the best value for maximazing player and Beta is the best value for minimazing player. If Alpha >= Beta at any point then other branches are prunned (It breaks out of the loop in the move list).
- Fail low: the score of the move is less or equal than Alpha wich means the move is too bad for maximazing player then the branch is pruned.
- Fail high: the score of the move is greater or equal to beta wich means opponent won't allow it.
- If the score is in between its the optimal and its Principla Variation move. (Principal Variation node is the principla variation move that is on the line of the most optimal sequence of move for both sides).

# Evaluation

# Add killer moves, history moves,pv, pv search, 